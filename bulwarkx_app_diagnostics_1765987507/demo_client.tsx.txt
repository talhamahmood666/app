"use client";

import { useEffect, useMemo, useState } from "react";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import {
  useAccount,
  useReadContract,
  useWriteContract,
  useWaitForTransactionReceipt,
} from "wagmi";
import { parseEther, isAddress, formatEther, decodeEventLog } from "viem";

import ABI from "@/contracts/BulwarkXEscrow.abi.json";
import { ESCROW_ADDRESSES } from "@/contracts/addresses";

type Hex = `0x${string}`;

function cx(...classes: Array<string | false | undefined | null>) {
  return classes.filter(Boolean).join(" ");
}

function explorerBase(): string {
  return process.env.NEXT_PUBLIC_BASESCAN_BASE || "https://sepolia.basescan.org";
}

function linkTx(hash?: Hex | null) {
  if (!hash) return null;
  return `${explorerBase()}/tx/${hash}`;
}
function linkAddr(addr?: Hex | null) {
  if (!addr) return null;
  return `${explorerBase()}/address/${addr}`;
}

function prettyError(err: unknown): string {
  const msg = String((err as any)?.shortMessage || (err as any)?.message || err || "");
  return msg.replaceAll("ContractFunctionExecutionError:", "").trim();
}

function nowUnix(): number {
  return Math.floor(Date.now() / 1000);
}

export default function DemoClient() {
  const { address, isConnected } = useAccount();

  const contractAddress = ESCROW_ADDRESSES.baseSepolia as Hex;

  // ----- Create escrow form -----
  const [payee, setPayee] = useState<string>("");
  const [arbiter, setArbiter] = useState<string>("");
  const [amountEth, setAmountEth] = useState<string>("0.001");
  const [autoReleaseMins, setAutoReleaseMins] = useState<string>("60");

  const releaseTime = useMemo(() => {
    const mins = Number(autoReleaseMins || "0");
    const clamped = Number.isFinite(mins) ? Math.max(0, mins) : 0;
    return nowUnix() + clamped * 60;
  }, [autoReleaseMins]);

  // ----- Escrow ID input / state -----
  const [escrowId, setEscrowId] = useState<string>("");
  const escrowIdHex = (escrowId || "").trim() as Hex;

  const escrowIdLooksValid =
    escrowIdHex.startsWith("0x") &&
    escrowIdHex.length === 66; // bytes32 = 32 bytes = 64 hex chars + 0x

  // Read escrow struct via public mapping getter: escrows(bytes32)
  const escrowRead = useReadContract({
    address: contractAddress,
    abi: ABI as any,
    functionName: "escrows",
    args: escrowIdLooksValid ? [escrowIdHex] : undefined,
    query: {
      enabled: escrowIdLooksValid,
      refetchInterval: 4000, // grant demo feel: "live"
    },
  });

  // ----- Write hooks -----
  const { writeContractAsync } = useWriteContract();

  const [lastTx, setLastTx] = useState<Hex | null>(null);
  const [statusMsg, setStatusMsg] = useState<string>("");
  const [errorMsg, setErrorMsg] = useState<string>("");

  const receipt = useWaitForTransactionReceipt({
    hash: lastTx || undefined,
  });

  // When tx completes, try to pull escrowId from event logs (if event exists in ABI)
  useEffect(() => {
    if (!receipt.data || !receipt.isSuccess) return;

    // If user already has escrowId, don’t override it
    if (escrowIdLooksValid) return;

    try {
      const logs = receipt.data.logs || [];
      for (const log of logs) {
        try {
          const decoded = decodeEventLog({
            abi: ABI as any,
            data: log.data,
            topics: log.topics,
          });

          // Heuristic: if any event arg is bytes32, take it
          const args = decoded?.args as Record<string, any> | undefined;
          if (args) {
            for (const key of Object.keys(args)) {
              const v = args[key];
              if (typeof v === "string" && v.startsWith("0x") && v.length === 66) {
                setEscrowId(v);
                setStatusMsg(`Escrow ID detected from tx log ✅`);
                return;
              }
            }
          }
        } catch {
          // ignore non-matching logs
        }
      }

      setStatusMsg(
        `Tx confirmed ✅ (If escrowId didn't auto-fill, copy it from the tx logs on BaseScan.)`
      );
    } catch {
      setStatusMsg(`Tx confirmed ✅`);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [receipt.isSuccess, receipt.data]);

  // ----- Derived escrow display -----
  const escrow = escrowRead.data as any;

  const escrowExists = useMemo(() => {
    // We don’t know the exact struct fields, so we do a robust check:
    // If it returns something and at least one address-like field is non-zero, assume it exists.
    if (!escrow) return false;
    const vals = Array.isArray(escrow) ? escrow : Object.values(escrow);
    const addrLike = vals.find(
      (v) => typeof v === "string" && v.startsWith("0x") && v.length === 42
    );
    return Boolean(addrLike && addrLike !== "0x0000000000000000000000000000000000000000");
  }, [escrow]);

  // Buttons should only enable when connected and escrowId valid
  const canAct = isConnected && escrowIdLooksValid;

  // ----- Actions -----
  async function handleCreateEscrow() {
    setErrorMsg("");
    setStatusMsg("");

    const payeeOk = isAddress(payee);
    const arbiterOk = isAddress(arbiter);
    if (!payeeOk) return setErrorMsg("Payee address is invalid.");
    if (!arbiterOk) return setErrorMsg("Arbiter address is invalid.");

    let value: bigint;
    try {
      value = parseEther(amountEth || "0");
      if (value <= 0n) return setErrorMsg("Amount must be > 0.");
    } catch {
      return setErrorMsg("Amount is invalid. Example: 0.01");
    }

    try {
      setStatusMsg("Submitting create escrow transaction…");
      const hash = await writeContractAsync({
        address: contractAddress,
        abi: ABI as any,
        // IMPORTANT: overloaded function support by full signature:
        functionName: "createEscrow(address,address,uint256)" as any,
        args: [payee as Hex, arbiter as Hex, BigInt(releaseTime)],
        value,
      });

      setLastTx(hash as Hex);
      setStatusMsg("Transaction submitted. Waiting for confirmation…");
    } catch (e) {
      setErrorMsg(prettyError(e));
      setStatusMsg("");
    }
  }

  async function handleRelease() {
    setErrorMsg("");
    setStatusMsg("");
    try {
      setStatusMsg("Submitting release…");
      const hash = await writeContractAsync({
        address: contractAddress,
        abi: ABI as any,
        functionName: "releaseEscrow(bytes32)" as any,
        args: [escrowIdHex],
      });
      setLastTx(hash as Hex);
